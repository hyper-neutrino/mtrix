(note: if a specified type combination isn't listed, it probably vectorizes)

nilads
------
³                                  1st argument, or 16
⁴                                  2nd argument, or 100
⁵                                  3rd argument, or 10
⁶                                  4th argument, or 64
⁷                                  5th argument, or 256
⁸                                  left argument, or '\n'
⁹                                  right argument, or ' '

monads
------
R   (z: re )                       Upper range; [1, 2, ..., z] or [0, -1, ..., z + 1]
    (z: im )                       Upper range; [i, 2i, ..., z] or [0, -i, ..., z + i]
    (z: cmp)                       Cartesian product over sum of the above
    (z: chr)                       Character range from "A"
ʀ   (z: re )                       Lower range; [0, 1, ..., z - 1] or [-1, -2, ..., z]
    (z: im )                       Lower range; [0, i, ..., z - i] or [-i, -2i, ..., z]
    (z: cmp)                       Cartesian product over sum of the above
    (z: chr)                       Character range from "a"
ɾ   (z: re )                       Outer range; [0, 1, ..., z] or [0, -1, ..., z]
    (z: im )                       Outer range; [0, i, ..., z] or [0, -i, ..., z]
    (z: cmp)                       Cartesian product over sum of the above
    (z: chr)                       Character range from "Γ"
ʁ   (z: re )                       Inner range; [1, 2, ..., z - 1] or [-1, -2, ..., z + 1]
    (z: im )                       Inner range; [i, 2i, ..., z - i] or [-i, -2i, ..., z + i]
    (z: cmp)                       Cartesian product over sum of the above
    (z: chr)                       Character range from "!"
¹   (z: any)                       z; identity; z => z
²   (z: num)                       z * z; square; squared
    (z: str)                       format z as square

dyads
-----
+   (x: num, y: num)               x + y; addition; plus; add
    (x: str, y: num)               x + y.toString(); concatenation
    (x: num, y: str)               x.toString() + y; concatenation
    (x: str, y: str)               x + y; concatenation
,   (x: any, y: any)               [x, y]; pair; (x, y) => [x, y]
_   (x: num, y: num)               x - y; subtraction; minus
    (x: chr, y: num)               chr(ord(x) - y); caesar cipher (ignores complex component)
    (x: num, y: chr)               chr(ord(y) + x); caesar cipher (ignores complex component)
    (x: chr, y: chr)               ?
×   (x: num, y: num)               x * y; multiplication; times
    (x: str, y: num)               pad right to up to y with spaces
    (x: num, y: str)               pad left to up to y with spaces
    (x: str, y: str)               [c + y for c in x]; vectorized concatenation
÷   (x: num, y: num)               x / y; division; divide
    (x: str, y: num)               split each line into segments of at most length y, then join all on newlines; if y == 0, no-op
    (x: num, y: str)               y / x
    (x: str, y: str)               x.match(y); regex match; regex find
